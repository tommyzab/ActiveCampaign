name: terraform-ci

on:
  push:
    branches: ["main"]
  pull_request:
  workflow_dispatch:
    inputs:
      run_apply:
        description: "Set to true to promote the latest plan into apply."
        required: false
        default: "false"

permissions:
  contents: read
  # id-token: write # Removed: Only needed for OIDC, not needed for Access Keys

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.7.5
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"

jobs:
  plan:
    name: Terraform fmt/validate/plan
    runs-on: ubuntu-latest
    outputs:
      plan_exists: ${{ steps.check_plan.outputs.exists }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      # --- FIXED: Using Access Keys instead of Role Assumption ---
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      # ---------------------------------------------------------

      - name: Export Okta Secrets
        env:
          OKTA_TOKEN: ${{ secrets.OKTA_API_TOKEN }}
          OKTA_ORG: ${{ secrets.OKTA_ORG_NAME }}
        run: |
          # Export Okta secrets directly (no dummy values)
          echo "TF_VAR_okta_api_token=${OKTA_TOKEN}" >> "$GITHUB_ENV"
          echo "TF_VAR_okta_org_name=${OKTA_ORG}" >> "$GITHUB_ENV"
          # Enable identity module if ENABLE_IDENTITY secret is set to 'true'
          echo "TF_VAR_enable_identity=${{ secrets.ENABLE_IDENTITY != '' && secrets.ENABLE_IDENTITY || 'false' }}" >> "$GITHUB_ENV"

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_TABLE }}" \
            -backend-config="key=global/s3/terraform.tfstate"

      - name: Terraform Fmt
        run: terraform fmt -check

      - name: Terraform Validate
        # Okta provider validation may fail when identity is disabled - this is expected
        continue-on-error: ${{ secrets.ENABLE_IDENTITY != 'true' }}
        run: terraform validate

      - name: Terraform Plan
        id: terraform_plan
        # Handle Okta provider validation errors gracefully when identity is disabled
        continue-on-error: ${{ secrets.ENABLE_IDENTITY != 'true' }}
        env:
          ENABLE_IDENTITY_FLAG: ${{ secrets.ENABLE_IDENTITY != '' && secrets.ENABLE_IDENTITY || 'false' }}
        run: |
          set +e  # Allow plan to fail without exiting immediately
          
          # Remove any existing plan file to ensure we start fresh
          rm -f tfplan.binary
          
          terraform plan -out=tfplan.binary > plan_output.txt 2>&1
          PLAN_EXIT=$?
          cat plan_output.txt
          
          # If identity is disabled and we see Okta errors, that's expected
          if [[ "$ENABLE_IDENTITY_FLAG" != "true" ]] && grep -qiE "(okta|401|unauthorized|failed.*validate|failed.*load.*sdk|API token.*missing)" plan_output.txt; then
            echo "⚠️  Okta provider error detected but identity is disabled - this is expected"
            # Don't upload plan if it failed due to Okta errors
            rm -f tfplan.binary
            echo "expected_okta_error=true" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "expected_okta_error=false" >> $GITHUB_OUTPUT
          fi
          
          # Only succeed if plan completed successfully (exit code 0) AND file exists
          if [[ $PLAN_EXIT -eq 0 ]] && [[ -f tfplan.binary ]]; then
            echo "✅ Plan file created successfully"
            exit 0
          else
            echo "❌ Plan failed or incomplete plan file"
            rm -f tfplan.binary
            exit $PLAN_EXIT
          fi

      - name: Check Plan File Exists
        id: check_plan
        if: always()
        run: |
          if [[ -f tfplan.binary ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "✅ Plan file exists and is ready"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "❌ Plan file does not exist"
            # Check if plan step failed
            if [[ "${{ steps.terraform_plan.outcome }}" != "success" ]]; then
              echo "⚠️  Terraform plan step failed - check the plan output above for errors"
            fi
          fi

      - name: Upload Plan Artifact
        if: steps.terraform_plan.outcome == 'success' && steps.check_plan.outputs.exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: tfplan.binary
          retention-days: 1

      - name: Fail Job If Plan Missing
        if: steps.check_plan.outputs.exists != 'true' && steps.terraform_plan.outputs.expected_okta_error != 'true'
        run: |
          echo "❌ Plan job cannot proceed without a valid plan file"
          echo "The terraform plan step must complete successfully to generate a plan file"
          echo ""
          echo "Common causes:"
          echo "  - Terraform configuration errors (check plan output above)"
          echo "  - Missing required variables or secrets"
          echo "  - AWS credential or permission issues"
          echo "  - Resource dependency conflicts"
          exit 1

  apply:
    name: Terraform Apply
    needs: plan
    # Auto-deploy on push to main (suitable for home assignments/testing)
    # For production, consider requiring manual approval via workflow_dispatch
    # Only run if plan job succeeded AND a plan file was actually created
    if: >-
      github.ref == 'refs/heads/main' &&
      github.event_name == 'push' &&
      needs.plan.result == 'success' &&
      needs.plan.outputs.plan_exists == 'true'
    runs-on: ubuntu-latest
    environment:
      name: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      # --- FIXED: Using Access Keys instead of Role Assumption ---
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      # ---------------------------------------------------------

      - name: Download Plan Artifact
        uses: actions/download-artifact@v4
        with:
          name: tfplan
          path: .

      - name: Terraform Init (Backend only)
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_TABLE }}" \
            -backend-config="key=global/s3/terraform.tfstate"

      - name: Verify Plan File
        run: |
          if [[ ! -f tfplan.binary ]]; then
            echo "❌ Error: Plan file not found"
            exit 1
          fi
          echo "✅ Plan file found"

      - name: Terraform Apply
        env:
          TF_VAR_okta_api_token: ${{ secrets.OKTA_API_TOKEN }}
          TF_VAR_okta_org_name: ${{ secrets.OKTA_ORG_NAME }}
          TF_VAR_enable_identity: ${{ secrets.ENABLE_IDENTITY != '' && secrets.ENABLE_IDENTITY || 'false' }}
        run: terraform apply tfplan.binary